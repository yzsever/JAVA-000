### 作业1&2总结
1. 使用 GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例。 
2. 使用压测工具(wrk或sb)，演练gateway-server-0.0.1-SNAPSHOT.jar 示例。 
根据上述自己对于1和2的演示，写一段对于不同 GC 的总结，提交到 Github。
---
前言：总结基于JDK8 Java HotSpot VM.

首先，JVM为什么要提供多个垃圾收集器？是因为Java要支持从台式机上的小程序到大型服务器上的Web服务，各种各样的应用程序。
> 问题1：我们需要知道不同的垃圾收集器的目标服务是谁？

通过下图基于串行GC的“比较垃圾收集中所用时间的百分比”，我们需要了解一个事实，当GC的占比越大时，系统吞吐量会逐渐下降。同时串行GC使用的处理器数量增大时，系统吞吐量也会逐渐下降，因为处理器切换具有额外的开销

![Comparing Percentage of Time Spent in Garbage Collection](https://github.com/yzsever/JAVA-000/blob/main/Week_02/03-SummaryOfDifferentGC/02-JavaPlatform%2CStandardEditionHotSpotVirtualMachineGarbageCollectionTuningGuide/01-Image/1-1.png?raw=true)

> 问题2：JVM调优到底在调什么？怎么调？

JVM为垃圾收集器，堆大小和运行时编译器提供了依赖于平台的默认选择。这些选择可满足不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的调整会动态调整堆的大小，以满足应用程序的指定行为。

有两种主要的垃圾收集性能度量：
1. 吞吐量：是长时间内未花费在垃圾收集上的总时间的百分比。吞吐量包括分配所花费的时间（但是通常不需要调整分配速度）。
2. 暂停：是指由于正在进行垃圾收集而导致应用程序无响应的时间。
其他事项：
1. 足迹：流程的工作集，以页和缓存行为单位。在物理内存有限或有许多进程的系统上，占用空间可能决定可伸缩性。即时性是指对象死掉到内存可用之间的时间，这是分布式系统（包括远程方法调用（RMI））的重要考虑因素。

**我们一直在说JVM调优，那到底在调什么呢？以前的理解是为了让JVM不出现异常情况，例如OOM，异常的停顿等。现在可以更直观的了解到就是这三个调整指标，降低最大暂停时间到业务接受范围，提升应用程序吞吐量到业务期望范围。减小占用空间提升可伸缩性**

那么怎么调呢？初印象：三个目标是相互影响的，所以要根据目标优先级进行调整：
1. 最大暂停时间目标
   - 选择合适的垃圾收集器
2. 应用程序吞吐量目标
   - 总堆大小：影响垃圾收集性能的最重要因素是总可用内存。由于收集是在世代填满时发生的，因此吞吐量与可用内存量成反比。
   - 年轻代大小
3. 足迹目标（占用空间）
   - 使用-Xms -Xmx参数

接下来我们需要了解各个垃圾收集器的特点，来帮助我们进行调优。

虚拟机合并了许多不同的垃圾收集算法，这些算法使用分代收集进行组合。

> 问题3：为什么要分代收集呢？

下图“对象生命周期的典型分布”中的蓝色区域是对象生命周期的典型分布。 x轴是对象寿命，以分配的字节为单位。 y轴上的字节数是具有相应生存期的对象中的总字节数。左侧的尖峰表示分配后不久可以回收的对象（换句话说，已经“死亡”）。 有些对象的寿命更长，因此分布向右延伸。一些应用程序的外观分布非常不同，但是令人惊讶的是，大量应用程序具有这种总体形状。所以根据该现象发明了分代收集方法。

![Typical Distribution for Lifetimes of Objects](https://github.com/yzsever/JAVA-000/blob/main/Week_02/03-SummaryOfDifferentGC/02-JavaPlatform%2CStandardEditionHotSpotVirtualMachineGarbageCollectionTuningGuide/01-Image/3-1.png?raw=true)

---

### 调堆的大小

#### 总堆
**影响垃圾收集性能的最重要因素是总可用内存。由于收集是在世代填满时发生的，因此吞吐量与可用内存量成反比。**

默认情况下，虚拟机在每个集合上增加或缩小堆，以尝试将每个集合中活动对象的可用空间比例保持在特定范围内：
1. -XX:MinHeapFreeRatio = minimum
2. -XX:MaxHeapFreeRatio = maximum

总大小限制参数：
1. -Xms min
2. -Xmx max

**总堆怎么调？以下是有关服务器应用程序堆大小的一般准则：**
- 除非您在暂停方面遇到问题，否则请尝试为虚拟机分配尽可能多的内存。默认大小通常太小。
- 将-Xms和-Xmx设置为相同的值可通过从虚拟机中删除最重要的大小确定决策来提高可预测性。但是，如果选择不当，虚拟机将无法补偿。
- 通常，由于分配可以并行化，因此随着处理器数量的增加而增加内存。

#### 年轻代大小
在总可用内存之后，**影响垃圾收集性能的第二大影响因素是专用于年轻代的堆的比例。**
年轻代越大，Minor GC的次数就越少。但是，对于有限的堆大小，较大的年轻代意味着较小的终身代，这将增加Major GC的频率。最佳选择取决于应用程序分配的对象的生命周期分布。

默认情况下，年轻代大小由参数NewRatio控制。
1. -XX:NewRatio=3表示年轻代和终身代之间的比率为1：3。换句话说，伊甸园空间和幸存者空间的总大小将是堆总大小的四分之一。
2. -XX:NewSize和-XX:MaxNewSize从下方和上方限制了年轻代的大小。将这些值设置为相同的值可以修复年轻代。

##### 幸存者空间大小
您可以使用参数-XX:SurvivorRatio来调整幸存空间的大小，**但这对性能通常并不重要。**
1. -XX：SurvivorRatio=6将伊甸园和幸存空间之间的比率设置为1：6。换句话说，每个幸存者空间将是伊甸园大小的六分之一，因此是年轻代的八分之一（而不是七分之一，因为有两个幸存者空间）。

**年轻代怎么调？以下是服务器应用程序的一般准则：**
- 首先确定您可以负担得起的虚拟机最大堆大小。然后针对年轻代绘制性能指标，以找到最佳设置。
   - 请注意，最大堆大小应始终小于计算机上安装的内存量，以避免过多的页面错误和崩溃。
- 如果总堆大小是固定的，则增加年轻代的大小需要减少终身代的大小。保持终身代足够大，以容纳应用程序在任何给定时间使用的所有实时数据，以及一定数量的闲置空间（10％到20％或更多）。
- 遵守先前对终身代的限制：
   - 给年轻代以足够的内存。
   - 随着处理器数量的增加，可以增加年轻代的大小，因为分配可以并行化。

---

### 可用垃圾收集器
> 问题1：我们需要知道不同的垃圾收集器的目标服务是谁？
Java HotSpot VM包括三种不同类型的收集器，每种收集器具有不同的性能特征。
- 串行收集器使用**单个线程**来执行所有垃圾收集工作，这使之相对有效，因为线程之间没有通信开销。它最适合**单处理器计算机**，因为它不能利用多处理器硬件，尽管它在多处理器上**对于数据集较小（最大约100MB）的应用很有用**。默认情况下，在某些硬件和操作系统配置上选择了串行收集器，或者可以通过选项-XX：+ UseSerialGC显式启用它。
- 并行收集器（也称为吞吐量收集器）**并行执行**Minor GC，这可以大大减少垃圾收集的开销。它适用于具有在**多处理器或多线程硬件上运行的中型到大型数据集的应用程序**。并行收集器在某些硬件和操作系统配置上默认为选中，或者可以通过选项-XX：+UseParallelGC显式启用。
   - **并行压缩是使并行收集器能够并行执行主要收集的功能**。如果没有并行压缩，则使用单个线程执行主要集合，这会大大限制可伸缩性。如果已指定选项-XX：+UseParallelGC，则默认情况下启用并行压缩。将其关闭的选项是-XX：-UseParallelOldGC。
- 大多数并发收集器会**同时执行其大部分工作（例如，在应用程序仍在运行时）**，以使垃圾收集暂停时间较短。它设计用于**具有中型到大型数据集的应用程序**，在这些应用程序中，**响应时间比整体吞吐量更重要，因为用于最小化暂停的技术会降低应用程序性能**。 Java HotSpot VM提供了两个主要是并发收集器之间的选择。请参阅大多数同时收集器。使用选项-XX:+UseConcMarkSweepGC启用CMS收集器，或使用-XX:+UseG1GC启用G1收集器。

### 选择垃圾收集器
> 问题4：我们该怎么选择垃圾收集器呢？
除非您的应用程序有非常严格的暂停时间要求，否则请先运行您的应用程序并允许VM选择收集器(使用默认收集器)。如有必要，请调整堆大小以提高性能。如果性能仍然不能达到您的目标，请使用以下准则作为选择收集器的起点。
- 如果应用程序的数据集较小（最大约100 MB），则选择带有选项-XX：+ UseSerialGC的串行收集器。
- 如果应用程序将在单个处理器上运行并且没有暂停时间要求，则让VM选择收集器，或使用选项-XX:+UseSerialGC选择串行收集器。
- 如果（a）峰值应用程序性能是第一要务，并且（b）没有暂停时间要求或可接受的暂停时间为1秒或更长时间，则让VM选择收集器，或使用-XX:+UseParallelGC选择并行收集器。
- 如果响应时间比总体吞吐量更重要，并且垃圾收集暂停时间必须保持小于大约1秒，那么请使用-XX:+UseConcMarkSweepGC或-XX:+UseG1GC选择并发收集器。

这些准则仅提供选择收集器的起点，因为性能取决于堆的大小，应用程序维护的实时数据量以及可用处理器的数量和速度。暂停时间对这些因素特别敏感，因此前面提到的1秒阈值仅是近似值：在许多数据大小和硬件组合上，并行收集器的暂停时间将超过1秒。相反，在某些组合上，并发收集器可能无法将暂停时间保持在1秒以内。

如果推荐的收集器未达到所需的性能，请首先尝试调整堆和生成大小以达到所需的目标。如果性能仍然不足，请尝试使用其他收集器：使用并发收集器减少暂停时间，并使用并行收集器增加多处理器硬件的总体吞吐量。

---

### 测试结果分析
下面对作业1和作业2的两个测试来分析不同的垃圾收集器，两种主要的垃圾收集性能度量分别为：
1. 吞吐量：是长时间内未花费在垃圾收集上的总时间的百分比。吞吐量包括分配所花费的时间（但是通常不需要调整分配速度）。
2. 暂停：是指由于正在进行垃圾收集而导致应用程序无响应的时间。
这个时候，再回头看我的测试，我发现之前根本没有考虑过对比暂停时间，所以我还得回去统计暂停时间的数据，哈哈。

#### 吞吐量
测试1:使用 GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例

> 代码中随机产生对象，所以测试结果不一定准确

![GCLogAnalysis压测结果](https://github.com/yzsever/JAVA-000/blob/main/Week_02/01-GCLogAnalysisTest/01-GCLogAnalysis%E5%8E%8B%E6%B5%8B%E7%BB%93%E6%9E%9C.png?raw=true)

1. 总堆大小为128m时，服务运行均发生了OOM，所以无数据。
2. 总堆大小从512m到4g时，G1的生成对象数一直都是最多的。
3. CMS的吞吐量量低于G1但是优于串行和并行GC，而且总堆越大时越明显。因为总堆变大时，年轻大也变大了，Minor GC次数将减少，同时Major GC可以并发执行。
4. 串行和并行GC在总堆大于1G后，吞吐量开始下降。
5. 本次测试并行GC在接近4G的时候吞吐量被串行GC反超，并行GC使用多线程进行垃圾回收，由于线程需要进行资源切换有额外的开销，所以在总堆很大的时候反而有更好的性能。

测试2:使用压测工具(wrk或sb)，演练gateway-server-0.0.1-SNAPSHOT.jar 示例

![gateway-server压测结果](https://github.com/yzsever/JAVA-000/blob/main/Week_02/02-gateway-serverTest/01-gateway-server压测结果.png?raw=true)

1. 并行GC的吞吐量整体好于CMS GC，在200m-800m左右时好于串行GC
2. G1 GC在128m时表现最好，有点反常。当堆很大时，性能高于其他GC
3. CMS在堆大小适中的时候，吞吐量的表现也很不错。


#### 暂停时间
测试1:使用 GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例

![GCLogAnalysis压测最大暂停时间](https://github.com/yzsever/JAVA-000/blob/main/Week_02/01-GCLogAnalysisTest/01-GCLogAnalysis压测最大暂停时间.png?raw=true)

1. 总堆小于2G时，G1的GC暂停时间是最小的。主要是因为G1是采用并发收集垃圾。
2. 128m->512m时，随着堆大小的增大，GC的暂停时间增大。
3. 512m->1g时, 随着堆大小的增大，GC的暂停时间减小。
4. CMS的暂停时间反常的比其他GC高，同时512m的时候，CMS的吞吐量并不高，怀疑是因为创建了大对象。

---

### 参考资料
[Java平台标准版HotSpot虚拟机垃圾收集调优指南](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html)
[Java平台标准版HotSpot虚拟机垃圾收集调优指南自己简单的Google翻译](https://github.com/yzsever/JAVA-000/tree/main/Week_02/03-SummaryOfDifferentGC/02-JavaPlatform%2CStandardEditionHotSpotVirtualMachineGarbageCollectionTuningGuide)
