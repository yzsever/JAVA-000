### 作业1&2总结
1. 使用 GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例。 
2. 使用压测工具(wrk或sb)，演练gateway-server-0.0.1-SNAPSHOT.jar 示例。 
根据上述自己对于1和2的演示，写一段对于不同 GC 的总结，提交到 Github。
---


串行收集器通常适合**大多数“小型”应用程序（那些需要高达100兆字节（在现代处理器上为MB）的堆**。其他收集器具有额外的开销或复杂性，这是特殊行为的代价。如果应用程序不需要备用收集器的特殊行为，请使用串行收集器。 **预计串行收集器不是最佳选择的一种情况是大型，高线程应用程序，该应用程序在具有大量内存和两个或多个处理器的计算机上运行。在此类服务器级计算机上运行应用程序时，默认情况下会选择并行收集器**。 请参阅“人体工程学”部分。


如“人体工程学”部分所述，人体工程学动态选择垃圾回收器，以在各种应用程序上提供良好的性能。串行垃圾收集器是为具有小型数据集的应用程序设计的，其默认参数被选择为对大多数小型应用程序有效。并行或吞吐量垃圾收集器旨在与具有中大型数据集的应用程序一起使用。人体工程学选择的堆大小参数以及自适应大小策略的功能旨在为服务器应用程序提供良好的性能。这些选择在大多数（但不是全部）情况下都有效，这导致了本文档的中心宗旨：

通常，为特定世代选择大小是这些考虑之间的权衡。例如，一个非常大的年轻一代可以最大化吞吐量，但是这样做会以占用空间，及时性和暂停时间为代价。可以通过使用少量的年轻一代来最小化年轻一代的停顿，但会降低吞吐量。 一代的大小不会影响另一代的收集频率和暂停时间。

没有选择世代大小的正确方法。最佳选择取决于应用程序使用内存的方式以及用户需求。因此，虚拟机对垃圾收集器的选择并非总是最佳选择，并且可能会被“调整世代大小”部分中介绍的命令行选项所覆盖。

[Java平台标准版HotSpot虚拟机垃圾收集调优指南](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html)