#### 线程池
1. Excutor: 执行者 – 顶层接口 
2. ExcutorService: 接口API 
3. ThreadFactory: 线程工厂 
4. Excutors: 工具类

#### Executor – 执行者 

线程池从功能上看，就是一个任务执行器
submit方法 -> 有返回值，用Future封装 execute方法 -> 无返回值
submit方法还异常可以在主线程中catch到。 
execute方法执行任务是捕捉不到异常的。

#### ExecutorService
重要方法 | 说明
void execute(Runnable command); | 执行可运行的任务
void shutdown(); | 关闭线程池
List<Runnable> shutdownNow(); | 立即关闭
Future<?> submit(Runnable task); | 提交任务; 允许获取执行结果
<T> Future<T> submit(Runnable task, T result); | 提交任务(指定结果); 控制|获取执行结果
<T> Future<T> submit(Callable<T> task); | 提交任务; 允许控制任务和获取执行结果

shutdown():停止接收新任务，原来的任务继续执行 shutdownNow():停止接收新任务，原来的任务停止执行 awaitTermination(long timeOut, TimeUnit unit):当前线程阻塞

#### ThreadFactory
 
重要方法 | 说明
Thread newThread(Runnable r); | 创建新线程

ThreadPoolExecutor提交任务逻辑: 
1. 判断 corePoolSize 【创建】
2. 加入 workQueue
3. 判断 maximumPoolSize 【创建】 
4. 执行拒绝策略处理器

#### 线程池参数
缓冲队列
BlockingQueue是双缓冲队列。BlockingQueue内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。
1. ArrayBlockingQueue:规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。
2. LinkedBlockingQueue:大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。 其所含的对象是FIFO顺序排序的。
3. PriorityBlockingQueue:类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。
4. SynchronizedQueue:特殊的BlockingQueue，对其的操作必须是放和取交替完成。

#### 线程池参数
拒绝策略
1. ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
2. ThreadPoolExecutor.DiscardPolicy:丢弃任务，但是不抛出异常。
3. ThreadPoolExecutor.DiscardOldestPolicy:丢弃队列最前面的任务，然后重新提交被拒绝的任务
4. ThreadPoolExecutor.CallerRunsPolicy:由调用线程(提交任务的线程)处理该任务

#### ThreadFactory示例
```java
    public class CustomThreadFactory implements ThreadFactory {
        private AtomicInteger serial = new AtomicInteger(0);

        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(r);
            thread.setDaemon(true); // 根据需要，设置守护线程 thread.setName("CustomeThread-" + serial.getAndIncrement()); return thread;
        }
    }
```

#### ThreadPoolExecutor
重要属性/方法 | 说明
int corePoolSize; | 核心线程数
int maximumPoolSize; | 最大线程数
ThreadFactory threadFactory; | 线程创建工厂
BlockingQueue<Runnable> workQueue; | 工作队列
RejectedExecutionHandler handler; | 拒绝策略处理器
void execute(Runnable command) | 执行
Future<?> submit(Runnable task) | 提交任务
submit(Runnable task, T result)| 提交任务
submit(Callable<T> task) | 提交任务


#### ThreadPoolExecutor示例
```java
    public static ThreadPoolExecutor initThreadPoolExecutor() {
        int coreSize = Runtime.getRuntime().availableProcessors();
        int maxSize = Runtime.getRuntime().availableProcessors() * 2;
        BlockingQueue<Runnable> workQueue = new
                LinkedBlockingDeque<>(500);
        CustomThreadFactory threadFactory = new CustomThreadFactory();
        ThreadPoolExecutor executor = new ThreadPoolExecutor(coreSize,
                maxSize,
                1, TimeUnit.MINUTES, workQueue, threadFactory);
        return executor;
    }
```


#### 创建线程池方法
1. newSingleThreadExecutor
创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
2.newFixedThreadPool
创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充 一个新线程。
3. newCachedThreadPool
创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，
那么就会回收部分空闲(60秒不执行任务)的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统(或者 说JVM)能够创建的最大线程大小。
4.newScheduledThreadPool
创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

#### Callable – 基础接口
重要方法 | 说明
V call() throws Exception; | 调用执行
对比:
• Runnable#run()没有返回值 
• Callable#call()方法有返回值

```java
    public class RandomSleepTask implements Callable<Integer> {
        @Override
        public Integer call() throws Exception {
            Integer sleep = new
                    Random().nextInt(10000);
            TimeUnit.MILLISECONDS.sleep(sleep);
            return sleep;
        }
    }
```


#### Future – 基础接口
重要方法 | 说明
boolean cancel(boolean mayInterruptIfRunning); | 取消任务(执行时是否打断)
boolean isCancelled(); | 是否被取消
boolean isDone(); | 是否执行完毕
V get() throws InterruptedException, ExecutionException; | 获取执行结果
V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; | 限时获取执行结果

```java
    public static void main(String[] args) throws Exception {
        Callable<Integer> task = new RandomSleepTask();
        ExecutorService executorService =
                initThreadPoolExecutor();
        Future<Integer> future1 = executorService.submit(task);
        Future<Integer> future2 = executorService.submit(task); // 等待执行结果
        Integer result1 = future1.get(1, TimeUnit.SECONDS);
        Integer result2 = future2.get(1, TimeUnit.SECONDS);
        System.out.println("result1=" + result1);
        System.out.println("result2=" + result2);
    }
```

